## توضیحات کلی

این برنامه به زبان c نوشته شده است و وظیفه آن مدیریت سفارشات و خرید از چند فروشگاه مختلف است.
این برنامه شامل چندین تابع برای ورود کاربران، خواندن لیست سفارشات، خواندن داده ها از فایل ها و دایرکتوری ها و در نهایت انجام عملیات خرید می باشد
همچنین از چندین نخ و فرآیند برای بهینه سازی عملکرد استفاده شده است.

---

---

## معرفی متغیر ها

- `int main_pid`: شناسه فرآیند اصلی
- `char username[100]`: نام کاربر
- `float price_threshold`: سقف خرید کاربر
- `order_list order_list_items[100]`: لیست سفارشات کاربر

---

---

## معرفی ساختار داده ها

### 1. `order_list`

این ساختار شامل اطلاعات مربوط به سفارشات کاربر است.

- `char name[50]`: نام محصول
- `int number`: تعداد محصول

---

### 2. `item`

این ساختار در واقع لیست خرید کاربر است که شامل اطلاعات مربوط به محصولات موجود در فروشگاه ها می باشد.

- `char path[200]`: مسیر فایل محصول
- `int number`: تعداد محصول
- `char name[50]`: نام محصول
- `float price`: قیمت محصول
- `float score`: امتیاز محصول
- `int entity`: موجودی محصول

---

---

## معرفی توابع اصلی

### 1. `login`

این تابع عملیات ورود کاربر به برنامه را انجام می دهد.

### عملکرد:

1- نام کاربر را می گیرد.

2- ???????????????????????????????????????????????????????????????????

---

### 2. `get_order_list`

این تابع برای جمع‌آوری لیست سفارشات و سقف خرید کاربر استفاده می‌شود.

### عملکرد:

1- از کاربر نام محصولات و تعداد آن ها را می گیرد.

2- پس از اتمام ورودی، سقف خرید را از کاربر می‌گیرد.

---

### 3. `is_in_order_list`

این تابع بررسی می‌کند که آیا یک محصول خاص در یک فروشگاه در لیست سفارشات کاربر وجود دارد یا خیر.
در واقع این تابع به تعداد تمام محصولات موجود در فروشگاه ها صدا زده می شود.

### عملکرد:

1- نام محصول را با لیست سفارشات مقایسه می‌کند.

2- در صورت وجود تعداد محصول را به `checking_item` می افزاید و مقدار `true` بر می گرداند.

---

### 4. `read_file`

این تابع اطلاعات یک محصول را از یک فایل txt می خواند.

### عملکرد:

1- نام فایل را به عنوان ورودی می گیرد.

2- اطلاعات محصول شامل نام، قیمت، امتیاز و موجودی را از فایل می خواند.

3- اگر محصول در لیست سفارشات کاربر وجود داشته باشد، آن را به ساختار `item` اضافه می کند.

4- در صورت بروز خطا، پیام های خطا را چاپ می کند و حافظه را آزاد می کند.

---

### 5. `create_thread`

این تابع برای هر فایل محصول یک نخ جدید ایجاد می کند.

### عملکرد:

1- دایرکتوری مشخص شده را باز می کند و تمام فایل‌ های موجود در Category ها را می خواند.

2- برای هر فایل، یک نخ جدید ایجاد کرده و تابع `read_file` را فراخوانی می کند.

3- پس از اتمام همه نخ ها، نتایج را جمع آوری کرده و به آرایه نتایج منتقل می‌کند.

---

### 6. `create_process`

این تابع برای هر فروشگاه و دایرکتوری (در مجموع 24 دایرکتوری) یک فرآیند جدید ایجاد می کند.

### عملکرد:

1- دایرکتوری مشخص شده را باز می کند و برای هر زیر دایرکتوری یک فرآیند جدید ایجاد می کند.

2- در فرآیند فرزند، تابع `create_thread` را برای خواندن اطلاعات محصولات فراخوانی می کند و نتایج را به سبد خرید اضافه می کند.

3- از یک لوله (pipe) برای ارتباط بین فرآیند والد و فرزندان استفاده می‌کند.

4- پس از خواندن اطلاعات، فرآین ها را منتظر می گذارد تا تمام فرآین های فرزند به اتمام برسند.

---

### 7. `order`

این تابع وظیفه محاسبه ارزش هر سبد خرید و شناسایی بهترین فروشگاه بر اساس ارزش محصولات را بر عهده دارد.

### عملکرد:

1- ارزش سبد خرید را برای هر فروشگاه محاسبه می کند.

2- برای هر محصول، ارزش را بر اساس قیمت ، تعداد و امتیاز آن محاسبه می کند و در آرایه ای ذخیره می کند.

3- سپس بهترین فروشگاه را بر اساس بیشترین ارزش محاسبه شده تعیین می کند.

---

### 8. `score`

هدف این تابع دریافت امتیاز از کاربر برای محصولات بهترین فروشگاه تعیین شده توسط تابع `order` است.

### عملکرد:

1- از کاربر می خواهد که امتیاز محصولات را در محدوده 0 تا 5 وارد کند.

2- فقط برای محصولاتی که متعلق به فروشگاه انتخاب شده هستند، امتیاز دریافت می کند.

3- امتیازات وارد شده را چاپ و ذخیره می کند.

---

### 9. `final`

این تابع برای نهایی کردن خری ها طراحی شده است.

### عملکرد:

؟؟؟؟؟؟؟؟؟؟؟؟؟؟؟؟؟؟؟؟؟؟؟؟؟؟؟؟؟؟؟؟؟؟؟؟؟؟؟؟؟؟؟؟؟؟؟؟؟؟؟؟؟

---

---

## نحوه ی اجرای برنامه

1- تابع `()main` نقطه شروع برنامه است.

2- ابتدا تابع `()login` اجرا می شود که در آن کاربر با وارد کردن اطلاعات خود، می تواند خرید را آغاز کند.

3- سپس با اجرای تابع `()get_order_list` کاربر می تواند لیست خرید و سقف خرید خود را وارد کند.

4- یک آرایه به نام `pipe_fd[2]` از نوع int برای ذخیره توصیف گر های لوله ایجاد می شود.

5- لوله ی `pipe(pipe_fd)` برای ارتباط بین فرآیند والد و فرزندان ایجاد می شود. اگر ایجاد لوله ناموفق باشد، خطا چاپ می شود و برنامه خاتمه می یابد.

6- با استفاده از دستور `;()main_pid = getpid` شناسه فرآیند اصلی برنامه دریافت می شود و در متغیر `main_pid` ذخیره می شود.

7- دو بار از تابع `()fork` استفاده می شود تا دو فرآیند فرزند ایجاد کند.
اگر `()fork` ناموفق باشد، پیام خطا چاپ می شود و برنامه خاتمه می یابد.

8- بر اساس اینکه کدام فرآیند فرزند در حال اجرا است، مسیر دایرکتوری فروشگاه (store_path) و نام فروشگاه تعیین می شود.

9- اگر فرآیند فرزند باشد:

9-1- با استفاده از دستور `;close(pipe_fd[0])` انتهای خواندن لوله بسته می شود.

9-2- سبد خرید (shopping_cart) و شمارنده آن (shopping_cart_count) تعریف می شود.

9-3- اطلاعات مربوط به فروشگاه پردازش می شود (با استفاده از توابع `()create_process` و `()create_thread` و `()read_file`) و سبد خرید به والد ارسال می شود.

10- اگر فرایند والد باشد:

10-1- والد منتظر می ماند تا همه فرآیند های فرزند به اتمام برسند.

10-2- پس از خاتمه فرزندان، داده‌های سبد خرید از لوله خوانده می شود و در ساختار `shop_cart` ذخیره می‌شود.

11- سپس سه نخ برای پردازش های مربوط به انتخاب بهترین سبد خرید، امتیازدهی و پردازش نهایی ایجاد می‌شود.

12- در نهایت پس از ایجاد و اجرای نخ های نهایی ، برنامه به پایان می رسد.
